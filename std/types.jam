/** import_parameters {
    "set": [ 
        "__typecheck", 
        "__typecheck_arg", 
        "__typecheck_arg_optional", 
        "__typecheck_arg_union", 
        "__typecheck_arg_union_optional", 
        "types" 
    ]
} */

let primitives = {
    nil: true,
    number: true,
    string: true,
    boolean: true,
    table: true,
    function: true,
    thread: true,
    userdata: true
};

let __typeerror = (i, v, e) 
    => error("bad argument #${i} to ${debug.getinfo(3, "nl").name} (${e} expected, got ${type v})", 3);

let __match_type = (c, v, t) =>
    if primitives #t, type v == t
    else c && c #t && ((c #t) v);

let __typecheck_arg = (c, i, v, t) => >> if !__match_type(c, v, t), __typeerror(i, v, t);

let __typecheck_arg_optional = (c, i, v, t) => 
    >> if (v ~= nil) && !__match_type(c, v, t), __typeerror(i, v, t .. " or nil");

let __typecheck_arg_union = (c, i, v, ts) => {
    for _, t in ipairs ts, if __match_type(c, v, t), => true;
    __typeerror(i, v, table.concat(ts, " or "));
};

let __typecheck_arg_union_optional = (c, i, v, ts) => {
    if v == nil, => true;
    for _, t in ipairs ts, if __match_type(c, v, t), => true;
    __typeerror(i, v, table.concat(ts, " or ") .. " or nil");
};

let types = {
    subclass_of: proto: table => arg => (type arg == "table") && (arg.__class == proto);
    has_metatable: t: table => arg => has_metatable(arg, t);
};

typechecks.exists = typechecks.exists || (x => x ~= nil);
typechecks.int = typechecks.int || (x => (type x == "number") && (math.fmod(x, 1) == 0));
typechecks.positive = typechecks.positive || (x => (type x == "number") && (math.fmod(x, 1) == 0) && x >= 0);
typechecks.natural = typechecks.natural || (x => (type x == "number") && (math.fmod(x, 1) == 0) && x > 0);

=> tbl (
    __typecheck, 
    __typecheck_arg, 
    __typecheck_arg_optional, 
    __typecheck_arg_union, 
    __typecheck_arg_union_optional, 
    types
);
