
set = prototype!;

set.constructor = elements... :=> {
    my._elements = { };
    for k, v in ipairs elements,
        my._elements #v = true;
};

set.new = elements... => set ...elements;

set.contains = e :=> my._elements #e == true;
set.has = set.contains;

set.add = e :=> >> my._elements #e = true;

set.remove = e :=> >> my._elements #e = nil;

set.size = () :=> table.length(my._elements);
set.cardinality = set.size;

set.strict_subset = (a, b) => {
    if a:size! >= b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.subset = (a, b) => {
    if a:size! > b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.equal_to = (a, b) => {
    if a:size! ~= b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.superset = (a, b) => b:subset a;
set.strict_superset = (a, b) => b:strict_subset a;
set.superset_eq = (a, b) => b:subset a;

set.iter = () :=> {
    let n = 0;
    let elements = tbl!;
    for k, _ in pairs my._elements, {
        elements #(len elements + 1) = k;
        n = n + 1;
    };

    let i = 0;
    => () => {
        i = i + 1;
        if i <= n, => elements #i;
    };
};

set.to_table = () :=> {
    let t = tbl!;
    for k, _ in pairs my._elements, t #(len t + 1) = k;
    => t;
};

set.shallow_copy = () :=> set ...self:to_table!;

set.clear = () :=> >> for x in self:iter!, my._elements #x = nil;

set.set_elements = t :=> {
    self:clear!;
    for item in t:iter!, my._elements #item = true;
};

set.__tostring = () :=> {
    let str = "{ ";
    let i, n = 0, table.length my._elements;
    for k, _ in pairs my._elements, {
        str = str .. tostring k;
        i = i + 1;
        if i < n, str = str .. ", ";
    };
    => str .. " }";
};

set.each = f :=> >> for k, v in pairs(my._elements), f k;

set.union = (a, b) => {
    let c = a:shallow_copy!;
    for x in b:iter!, c._elements #x = true;
    => c;
};

set.intersect = (a, b) => {
    let c = set!;
    for x in a:iter!, if b._elements #x, c._elements #x = true;
    => c;
};

set.difference = (a, b) => {
    let c = a:shallow_copy!;
    for x in b:iter!, c._elements #x = nil;
    => c;
};

set.unpack = () :=> ...self:to_table!;
