/** import_parameters {
    "set": [ "set" ]
} */

use "std/types.jam";
use "std/table.jam";

let set = prototype!;

checkers.set = checks.generate_from_prototype "set";

set.__type = "set";

set.constructor = elements... [set] :=> {
    my._elements = { };
    for k, v in ipairs elements,
        my._elements #v = true;
};

set.new = elements... => set ...elements;

set.contains = e: exists [set] :=> my._elements #e == true;
set.has = set.contains;

set.add = e: exists [set] :=> >> my._elements #e = true;

set.remove = e: exists [set] :=> >> my._elements #e = nil;

set.size = () [set] :=> table.length(my._elements);
set.cardinality = set.size;

set.strict_subset = (a: set, b: set) => {
    if a:size! >= b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.subset = (a: set, b: set) => {
    if a:size! > b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.equal_to = (a: set, b: set) => {
    if a:size! ~= b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.superset = (a: set, b: set) => b:subset a;
set.strict_superset = (a: set, b: set) => b:strict_subset a;
set.superset_eq = (a: set, b: set) => b:subset a;

set.iter = () [set] :=> {
    let n = 0;
    let elements = tbl!;
    for k, _ in pairs my._elements, {
        elements #(len elements + 1) = k;
        n = n + 1;
    };

    let i = 0;
    => () => {
        i = i + 1;
        if i <= n, => elements #i;
    };
};

set.to_table = () [set] :=> reduce({ }, tbl pairs my._elements, table.set);

set.shallow_copy = () [set] :=> set ...self:to_table!;

set.clear = () [set] :=> >> for x in self:iter!, my._elements #x = nil;

set.set_elements = t: set [set] :=> {
    self:clear!;
    for item in t:iter!, my._elements #item = true;
};

set.__tostring = () [set] :=> {
    let str = "{ ";
    let i, n = 0, table.length my._elements;
    for k, _ in pairs my._elements, {
        str = str .. tostring k;
        i = i + 1;
        if i < n, str = str .. ", ";
    };
    => str .. " }";
};

set.each = f: function [set] :=> >> for k, v in pairs(my._elements), f k;

set.union = (a: set, b: set) => {
    let c = a:shallow_copy!;
    for x in b:iter!, c._elements #x = true;
    => c;
};

set.intersect = (a: set, b: set) => {
    let c = set!;
    for x in a:iter!, if b._elements #x, c._elements #x = true;
    => c;
};

set.difference = (a: set, b: set) => {
    let c = a:shallow_copy!;
    for x in b:iter!, c._elements #x = nil;
    => c;
};

set.unpack = () [set] :=> ...self:to_table!;

=> tbl set;
