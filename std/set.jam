/** import_parameters {
    "set": [ "set" ]
} */

use "std/types.jam";
use "std/table.jam";
use "std/iter.jam";

let set = prototype!;
set.__type = "set";

typechecks.set = types.generate_from_prototype set;

set.constructor = elements... [set] :=> {
    my._elements = { };
    for k, v in pairs elements, my._elements #v = true;
};

set.new = elements... => set ...elements;

set.contains = e: exists [set] :=> my._elements #e == true;
set.has = set.contains;

set.add = e: exists [set] :=> >> my._elements #e = true;

set.remove = e: exists [set] :=> >> my._elements #e = nil;

set.size = () [set] :=> table.length(my._elements);
set.cardinality = set.size;

set.strict_subset = (a: set, b: set) => {
    if a:size! >= b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.subset = (a: set, b: set) => {
    if a:size! > b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.equal_to = (a: set, b: set) => {
    if a:size! ~= b:size!, => false;
    for k, _ in pairs a._elements, if !(b._elements #k), => false;
    => true;
};

set.superset = (a: set, b: set) => b:subset a;
set.strict_superset = (a: set, b: set) => b:strict_subset a;
set.superset_eq = (a: set, b: set) => b:subset a;

set.iter = () [set] :=> {
    let elements = self:to_table!;
    let n = len elements;
    let i = 0;
    => () => {
        i = i + 1;
        if i <= n, => elements #i;
    };
};

set.to_table = () [set] :=> reduce({ }, tbl pairs my._elements, table.push);

set.shallow_copy = () [set] :=> set ...self:to_table!;

set.clear = () [set] :=> >> for x in self:iter!, my._elements #x = nil;

set.set_elements = t: set [set] :=> {
    self:clear!;
    for item in t:iter!, my._elements #item = true;
};

set.__tostring = () [set] :=> {
    let str = "{ ";
    let i, n = 0, table.length my._elements;
    for k, _ in pairs my._elements, {
        str = str .. tostring k;
        i = i + 1;
        if i < n, str = str .. ", ";
    };
    => str .. " }";
};

set.each = f: function [set] :=> >> for k, v in pairs(my._elements), f k;

set.union = (a: set, b: set) => {
    let c = a:shallow_copy!;
    for x in b:iter!, c._elements #x = true;
    => c;
};

set.intersect = (a: set, b: set) => {
    let c = set!;
    for x in a:iter!, if b._elements #x, c._elements #x = true;
    => c;
};

set.difference = (a: set, b: set) => {
    let c = a:shallow_copy!;
    for x in b:iter!, c._elements #x = nil;
    => c;
};

set.unpack = () [set] :=> ...self:to_table!;

=> tbl set;
