/** import_parameters {
    "set": [ "map" ]
} */

use "std/iter.jam";
use "std/types.jam";
use "std/table.jam";

let map = prototype!;

checkers.map = types.generate_from_prototype "map";

map.__type = "map";

map.constructor = (t: table = { }) [map] :=> >> my._elements = t;

map.set = (k: exists, v) [map] :=> >> my._elements #k = v;
map.get = k: exists [map] :=> my._elements #k;
map.has = k: exists [map] :=> bool my._elements #k;
map.remove = k: exists [map] :=> >> my._elements #k = nil;
map.clear = () [map] :=> >> for k, v in pairs my._elements, my._elements #k = nil;

map.size = () [map] :=> reduce(0, tbl pairs my._elements, n => n + 1);
map.keys = () [map] :=> reduce({ }, tbl pairs my._elements, table.push);
map.values = () [map] :=> reduce({ }, tbl pairs my._elements, (t, k, v) => >> t #(len t + 1) = v);

map.to_table = () [map] :=> reduce({ }, tbl pairs my._elements, table.set);
map.shallow_copy = () [map] :=> map self:to_table!;
map.pairs = () [map] :=> pairs my._elements;
map.set_elements = t: table [map] :=> {
    self:clear!;
    for k, v in pairs t, my._elements #k = v;
};

map.each = f: function [set] :=> >> for k, v in pairs my._elements, f k;
map.merge = (a: map, b: map) 
    => reduce(a:shallow_copy!, tbl pairs b._elements, table.set);

=> tbl map;
